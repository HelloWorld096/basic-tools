<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CSS Color Filter Generator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .filter-pixel {
      background-color: white;
    }
  </style>
</head>
<body class="min-h-screen bg-gray-50 py-8 px-4">
  <div class="max-w-md mx-auto">
    <!-- Header -->
    <div class="text-center mb-8">
      <h1 class="text-2xl font-light text-gray-900 mb-2">CSS Color Filter Generator</h1>
      <p class="text-sm text-gray-500">Generate CSS filters to transform white to any color</p>
    </div>

    <!-- Main Card -->
    <div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
      <!-- Input Section -->
      <div class="p-6 border-b border-gray-100">
        <label for="target-color" class="block text-sm font-medium text-gray-700 mb-3">
          Target Color
        </label>
        <div class="flex gap-3">
          <input 
            type="text" 
            id="target-color" 
            placeholder="#00a4d6" 
            value="#00a4d6" 
            maxlength="7"
            class="flex-1 px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          />
          <button 
            id="compute-btn"
            class="px-4 py-2 bg-gray-900 text-white text-sm font-medium rounded-md hover:bg-gray-800 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
          >
            Generate
          </button>
        </div>
      </div>

      <!-- Results Section -->
      <div class="p-6">
        <!-- Color Swatches -->
        <div class="grid grid-cols-2 gap-4 mb-6">
          <div class="text-center">
            <div class="text-xs font-medium text-gray-500 mb-2">Original</div>
            <div class="w-full aspect-square rounded-lg border border-gray-200 overflow-hidden">
              <div class="realPixel w-full h-full bg-blue-500"></div>
            </div>
          </div>
          <div class="text-center">
            <div class="text-xs font-medium text-gray-500 mb-2">Filtered</div>
            <div class="w-full aspect-square rounded-lg border border-gray-200 overflow-hidden">
              <div class="filterPixel filter-pixel w-full h-full"></div>
            </div>
          </div>
        </div>

        <!-- Filter Details -->
        <div class="space-y-3">
          <div>
            <div class="flex items-center justify-between mb-2">
              <span class="text-xs font-medium text-gray-500">CSS Filter</span>
              <button 
                id="copy-btn" 
                class="px-2 py-1 text-xs bg-gray-100 text-gray-700 rounded hover:bg-gray-200 transition-colors"
                title="Copy filter string to clipboard"
              >
                Copy
              </button>
            </div>
            <div class="filterDetail text-xs font-mono text-gray-900 bg-gray-50 p-2 rounded border break-all">
              –
            </div>
          </div>
          
          <div>
            <span class="text-xs font-medium text-gray-500">Accuracy Loss: </span>
            <span class="lossDetail text-xs text-gray-900">–</span>
          </div>
        </div>

        <!-- Note -->
        <div class="mt-4 p-3 bg-gray-50 rounded-md">
          <p class="text-xs text-gray-600">
            The generator automatically retries until achieving high accuracy (loss ≤ 8). 
            Click "Generate" again if you want a different result.
          </p>
        </div>
      </div>
    </div>
  </div>

  <script>
  'use strict';

  //
  // == Color Utility Class ==
  //
  class Color {
    constructor(r, g, b) {
      this.set(r, g, b);
    }
    set(r, g, b) {
      this.r = Color.clamp(r);
      this.g = Color.clamp(g);
      this.b = Color.clamp(b);
    }
    static clamp(x) {
      return Math.min(255, Math.max(0, x));
    }
    toString() {
      return `rgb(${Math.round(this.r)}, ${Math.round(this.g)}, ${Math.round(this.b)})`;
    }

    // Multiply the current [r,g,b] by a 3×3 matrix (array length 9)
    multiply(matrix) {
      const { r, g, b } = this;
      this.r = Color.clamp(r * matrix[0] + g * matrix[1] + b * matrix[2]);
      this.g = Color.clamp(r * matrix[3] + g * matrix[4] + b * matrix[5]);
      this.b = Color.clamp(r * matrix[6] + g * matrix[7] + b * matrix[8]);
    }

    hueRotate(angle = 0) {
      const rad = angle * Math.PI / 180;
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      // From W3C filter-effects spec:
      this.multiply([
        0.213 + cos * 0.787 - sin * 0.213,
        0.715 - cos * 0.715 - sin * 0.715,
        0.072 - cos * 0.072 + sin * 0.928,
        0.213 - cos * 0.213 + sin * 0.143,
        0.715 + cos * 0.285 + sin * 0.140,
        0.072 - cos * 0.072 - sin * 0.283,
        0.213 - cos * 0.213 - sin * 0.787,
        0.715 - cos * 0.715 + sin * 0.715,
        0.072 + cos * 0.928 + sin * 0.072
      ]);
    }

    grayscale(value = 1) {
      this.multiply([
        0.2126 + 0.7874 * (1 - value),
        0.7152 - 0.7152 * (1 - value),
        0.0722 - 0.0722 * (1 - value),
        0.2126 - 0.2126 * (1 - value),
        0.7152 + 0.2848 * (1 - value),
        0.0722 - 0.0722 * (1 - value),
        0.2126 - 0.2126 * (1 - value),
        0.7152 - 0.7152 * (1 - value),
        0.0722 + 0.9278 * (1 - value)
      ]);
    }

    sepia(value = 1) {
      this.multiply([
        0.393 + 0.607 * (1 - value),
        0.769 - 0.769 * (1 - value),
        0.189 - 0.189 * (1 - value),
        0.349 - 0.349 * (1 - value),
        0.686 + 0.314 * (1 - value),
        0.168 - 0.168 * (1 - value),
        0.272 - 0.272 * (1 - value),
        0.534 - 0.534 * (1 - value),
        0.131 + 0.869 * (1 - value)
      ]);
    }

    saturate(value = 1) {
      this.multiply([
        0.213 + 0.787 * value,
        0.715 - 0.715 * value,
        0.072 - 0.072 * value,
        0.213 - 0.213 * value,
        0.715 + 0.285 * value,
        0.072 - 0.072 * value,
        0.213 - 0.213 * value,
        0.715 - 0.715 * value,
        0.072 + 0.928 * value
      ]);
    }

    brightness(value = 1) {
      this.r = Color.clamp(this.r * value);
      this.g = Color.clamp(this.g * value);
      this.b = Color.clamp(this.b * value);
    }

    contrast(value = 1) {
      this.r = Color.clamp((this.r - 128) * value + 128);
      this.g = Color.clamp((this.g - 128) * value + 128);
      this.b = Color.clamp((this.b - 128) * value + 128);
    }

    invert(value = 1) {
      this.r = Color.clamp((1 - value) * this.r + value * (255 - this.r));
      this.g = Color.clamp((1 - value) * this.g + value * (255 - this.g));
      this.b = Color.clamp((1 - value) * this.b + value * (255 - this.b));
    }
  }


  //
  // == Solver with Auto-Retry (loss ≤ 8) ==
  //
  class AutoRetrySolver {
    constructor(targetColor) {
      this.target = targetColor;
      // No fixed "starting params"; we randomize each pass anyway
      this.bestParams = null;
      this.bestLoss = Infinity;
    }

    // Given a parameter array [invert, sepia, saturate, hue, brightness, contrast],
    // apply all filters to pure white (255,255,255) → returns a Color instance.
    _applyFilters(params) {
      const c = new Color(255, 255, 255);
      c.invert(params[0]);
      c.sepia(params[1]);
      c.saturate(params[2]);
      c.hueRotate(params[3]);
      c.brightness(params[4]);
      c.contrast(params[5]);
      return c;
    }

    // Squared-error loss between "filtered white" and target
    _loss(params) {
      const c = this._applyFilters(params);
      return (c.r - this.target.r) ** 2 +
             (c.g - this.target.g) ** 2 +
             (c.b - this.target.b) ** 2;
    }

    // One stochastic pass: start from startParams, run `iterations` with initial `temp`, return best found.
    _stochasticPass(startParams, iterations, temp) {
      let current = [...startParams];
      let currentLoss = this._loss(current);
      let best = { params: [...current], loss: currentLoss };

      for (let i = 0; i < iterations; i++) {
        const t = temp * (1 - i / iterations);  // cooling schedule
        const candidate = current.map((v, idx) => {
          // Each parameter's valid range
          const ranges = [
            [0, 1],      // invert
            [0, 1],      // sepia
            [0, 20],     // saturate (wider range)
            [0, 360],    // hue-rotate
            [0, 20],     // brightness (wider)
            [0, 20]      // contrast (wider)
          ];
          const [minV, maxV] = ranges[idx];
          const delta = (Math.random() * 2 - 1) * (maxV - minV) * t;
          let next = v + delta;
          return Math.max(minV, Math.min(maxV, next));
        });

        const loss = this._loss(candidate);
        // Accept if better OR with probability e^((currentLoss-loss)/t)
        if (loss < currentLoss || Math.random() < Math.exp((currentLoss - loss) / t)) {
          current = candidate;
          currentLoss = loss;
        }
        if (currentLoss < best.loss) {
          best = { params: [...current], loss: currentLoss };
        }
      }

      return best;
    }

    // Run multiple "coarse→fine" passes until loss ≤ 8, then return the best set.
    solve() {
      // We'll keep trying until we hit loss ≤ 8.
      // Each attempt does: random start → 3 000 coarse @ temp=0.5 → 7 000 fine @ temp=0.025
      // If result.loss > 8, we just go again.
      while (true) {
        // Randomize start params
        const randomStart = [
          Math.random(),           // invert ∈ [0,1]
          Math.random(),           // sepia ∈ [0,1]
          1 + Math.random() * 19,  // saturate ∈ [1,20]
          Math.random() * 360,     // hue ∈ [0,360)
          1 + Math.random() * 19,  // brightness ∈ [1,20]
          1 + Math.random() * 19   // contrast ∈ [1,20]
        ];

        // Phase 1 (coarse search)
        const phase1 = this._stochasticPass(randomStart, 3000, 0.5);
        // Phase 2 (fine search)
        const phase2 = this._stochasticPass(phase1.params, 7000, 0.025);

        if (phase2.loss <= 8) {
          // Acceptable match
          this.bestParams = phase2.params;
          this.bestLoss = phase2.loss;
          return { params: this.bestParams, loss: this.bestLoss };
        }
        // Otherwise: loop and try again
      }
    }
  }

  // Convert "#abc" or "#aabbcc" → Color instance
  function hexToColor(hex) {
    if (hex.startsWith('#')) hex = hex.slice(1);
    if (hex.length === 3) {
      hex = hex.split('').map(ch => ch + ch).join('');
    }
    const intVal = parseInt(hex, 16);
    const r = (intVal >> 16) & 255;
    const g = (intVal >> 8) & 255;
    const b = intVal & 255;
    return new Color(r, g, b);
  }

  // Build the single CSS filter string from [invert, sepia, saturate, hue, brightness, contrast]
  function buildFilterString([invert, sepia, saturate, hue, brightness, contrast]) {
    const parts = [];
    parts.push(`invert(${(invert * 100).toFixed(1)}%)`);
    parts.push(`sepia(${(sepia * 100).toFixed(1)}%)`);
    parts.push(`saturate(${(saturate * 100).toFixed(1)}%)`);
    parts.push(`hue-rotate(${hue.toFixed(0)}deg)`);
    parts.push(`brightness(${(brightness * 100).toFixed(1)}%)`);
    parts.push(`contrast(${(contrast * 100).toFixed(1)}%)`);
    return parts.join(' ');
  }

  document.addEventListener('DOMContentLoaded', () => {
    const input = document.getElementById('target-color');
    const btn = document.getElementById('compute-btn');
    const realPixel = document.querySelector('.realPixel');
    const filterPixel = document.querySelector('.filterPixel');
    const filterDetail = document.querySelector('.filterDetail');
    const lossDetail = document.querySelector('.lossDetail');
    const copyBtn = document.getElementById('copy-btn');

    function updateReal(hex) {
      realPixel.style.backgroundColor = hex;
    }

    // Copy the filter string into the clipboard
    copyBtn.addEventListener('click', () => {
      const text = filterDetail.textContent.trim();
      if (text && text !== '–') {
        navigator.clipboard.writeText(text)
          .then(() => {
            const original = copyBtn.textContent;
            copyBtn.textContent = 'Copied!';
            copyBtn.classList.add('bg-green-100', 'text-green-700');
            copyBtn.classList.remove('bg-gray-100', 'text-gray-700');
            setTimeout(() => { 
              copyBtn.textContent = original; 
              copyBtn.classList.remove('bg-green-100', 'text-green-700');
              copyBtn.classList.add('bg-gray-100', 'text-gray-700');
            }, 1500);
          })
          .catch(() => {
            alert('Failed to copy. You can select and copy manually.');
          });
      } else {
        alert('No CSS filter string to copy yet.');
      }
    });

    btn.addEventListener('click', () => {
      let hex = input.value.trim();
      if (!/^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/.test(hex)) {
        alert('Please enter a valid 3- or 6-digit hex code (e.g. #f06 or #33ccff).');
        return;
      }

      const targetColor = hexToColor(hex);
      updateReal(hex);

      btn.textContent = 'Generating...';
      btn.disabled = true;
      filterDetail.textContent = '–';
      lossDetail.textContent = '–';
      filterPixel.style.filter = ''; 

      // Delay slightly so the UI updates before the heavy loop starts
      setTimeout(() => {
        const solver = new AutoRetrySolver(targetColor);
        const { params, loss } = solver.solve();
        const filterStr = buildFilterString(params);

        filterPixel.style.filter = filterStr;
        filterDetail.textContent = filterStr;
        lossDetail.textContent = loss.toFixed(2);

        btn.textContent = 'Generate';
        btn.disabled = false;
      }, 20);
    });

    // On initial load, show the default "real" color
    updateReal(input.value);
    filterPixel.style.filter = '';
  });
  </script>
</body>
</html>